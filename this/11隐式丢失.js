// 一种更微妙、更常见并且更出乎意料的情况发生在传入回调函数时：
function foo() { 
    console.log( this.a ); 
}
function doFoo(fn) { 
    // fn 其实引用的是 foo 
    fn(); // <-- 调用位置！ 
}
var obj = { 
    a: 2, 
    foo: foo 
};
var a = "oops, global"; // a 是全局对象的属性 
// obj.foo() // 2
doFoo( obj.foo ); // "oops, global"

// 参数传递其实就是一种隐式赋值，因此我们传入函数时也会被隐式赋值，所以结果和上一个例子一样。
// 就像我们看到的那样，回调函数丢失 this 绑定是非常常见的。
// 。除此之外，还有一种情 况 this 的行为会出乎我们意料：调用回调函数的函数可能会修改 this。
// 在一些流行的 JavaScript 库中事件处理器常会把回调函数的 this 强制绑定到触发事件的 DOM 元素上。
// 这在一些情况下可能很有用，但是有时它可能会让你感到非常郁闷。
// 无论是哪种情况，this 的改变都是意想不到的，实际上你无法控制回调函数的执行方式， 因此就没有办法控制会影响绑定的调用位置。
// 之后我们会介绍如何通过固定 this 来修复 （这里是双关，“修复”和“固定”的英语单词都是 fixing）这个问题。